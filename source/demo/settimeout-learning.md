---
title: setTimeout总结
date: 2017-09-11 15:47:38
pages: demo
---
_(:з」∠)_ 
关于setTimeout的总结向
### setTimeout不能作为多线程使用，js引擎执行是单线程的
最好证明：
```javascript
var isEnd = true;
window.setTimeout(function () {
    isEnd = false;//1s后，改变isEnd的值
}, 1000);
while (isEnd);
alert('end');
```
这段代码会死循环

### js是基于事件驱动的语言.它的执行顺序是遵循一个叫做事件队列的机制
执行的时候就是在逐步执行队列里面的事务。
setTimeout就是，线程会在指定时间后往事件队列里面插入一个任务。

### js引擎与GUI引擎是互斥的
GUI引擎在渲染时会阻塞js引擎计算。
如果在GUI渲染的时候,js改变了dom,那么就会造成渲染不同步。
异步操作都会被延迟到同步计算之后执行.也就是代码的执行顺序变了。

### requestAnimationFrame
* requestAnimationFrame 会**把每一帧中的所有DOM操作集中起来**，**在一次重绘或回流中就完成**，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧,每帧大约16毫秒.
* **在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流**，这当然就意味着更少的的cpu，gpu和内存使用量。
* 但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且**如果页面不是激活状态下的话，动画会自动暂停**，有效节省了CPU开销。

### 总结
* **浏览器的内核是多线程的**，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：**javascript引擎线程**，**GUI渲染线程**，**浏览器事件触发线程**。
* javascript引擎是**基于事件驱动单线程执行**的.JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。
* 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 **GUI渲染线程与JS引擎是互斥的**，**当JS引擎执行时GUI线程会被挂起**，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
* 当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。
